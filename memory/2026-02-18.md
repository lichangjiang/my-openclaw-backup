# 2026-02-18 Memory

## OpenSpec Day 7 学习完成

### 学习时间
- 开始时间：2026-02-18 10:06 UTC
- 学习内容：深入理解 OpenSpec 底层实现原理
- 学习时长：约 3-4 小时

### 学习成果

#### Part 1: Delta Spec 机制
- **格式定义**：ADDED/MODIFIED/REMOVED/RENAMED 四种操作
- **解析器**：`src/core/parsers/change-parser.ts` - 识别章节、提取需求块、解析场景
- **验证器**：`src/core/validation/validator.ts` - 重复检查、冲突检查、格式要求
- **合并逻辑**：`src/core/specs-apply.ts` - 正确的合并顺序（RENAMED → REMOVED → MODIFIED → ADDED）

#### Part 2: 工件生成机制
- **模板系统**：`schemas/spec-driven/templates/` - 四个工件模板
  - proposal.md：变更提案（Why, What Changes, Capabilities, Impact）
  - design.md：设计文档（Context, Goals/Non-Goals, Decisions, Risks）
  - tasks.md：任务清单（按章节组织的复选框）
  - spec.md：Delta Spec（ADDED/MODIFIED/REMOVED/RENAMED 章节）
- **AI 指令生成**：`src/commands/workflow/instructions.ts` - 包含 task、context、rules、dependencies、template
- **模板 vs AI 分工**：模板定义结构，AI 填充内容

#### Part 3: 任务执行机制
- **任务组织**：按章节（Infrastructure → Components → Features → Testing）
- **进度追踪**：`src/utils/task-progress.ts` - 解析复选框、计算进度百分比
- **执行顺序**：推荐顺序 + 并行任务支持

#### Part 4: 归档机制
- **Delta Specs 合并**：查找 → 准备 → 验证 → 写入
- **主规范更新**：`src/core/specs-apply.ts` - 重建文件、保持格式一致性
- **归档组织**：`src/core/archive.ts` - 带日期的归档目录（YYYY-MM-DD-<change-name>/）

### 三个思考问题的答案

#### Q1: 如果 Delta Spec 中同时有 MODIFIED 和 REMOVED 同一个需求，会发生什么？
**答案**：会发生验证错误，归档会被阻止。验证器会检测跨章节冲突，用户必须手动修正 Delta Spec。

**代码位置**：`src/core/validation/validator.ts`
```typescript
// 跨章节冲突检查
for (const n of modifiedNames) {
  if (removedNames.has(n)) {
    issues.push({
      level: 'ERROR',
      path: entryPath,
      message: `Requirement present in both MODIFIED and REMOVED: "${n}"`
    });
  }
}
```

#### Q2: 工件生成是模板化还是 AI 生成？
**答案**：是**模板化 + AI 填充**的混合模式。

| 方式 | 职责 |
|------|------|
| **模板** | 定义结构（保证一致性、降低难度、易于维护） |
| **AI** | 填充内容（理解 context、遵循 rules、生成符合规范的文档） |

为什么选择混合模式？
- ✅ 结构一致
- ✅ 内容质量高
- ✅ 易于维护

#### Q3: 归档后的主规范如何保持一致性？
**答案**：通过多层次的验证和重建机制：

1. **应用前验证**：验证 Delta Specs，阻止归档如果有错误
2. **重建后验证**：验证重建的规范，确保格式正确
3. **正确的合并顺序**：RENAMED → REMOVED → MODIFIED → ADDED
4. **重复和冲突检查**：章节内重复、跨章节冲突
5. **错误处理和回滚**：准备失败不写入，保持原样
6. **跨平台兼容性**：Windows 上使用 copy + remove，避免 EPERM 错误

### 学习笔记

- **文件位置**：`/home/lichangjiang/.openclaw/workspace/openspec-learning-day7-notes.md`
- **字数**：约 1.5 万字
- **内容**：
  - 详细的机制解释
  - 代码示例
  - 流程图说明
  - 三个思考问题的详细解答
  - 源码文件清单

### 已掌握的核心概念

✅ Delta Spec 机制（格式、解析、验证、合并）
✅ 工件生成机制（模板系统、AI 指令生成、模板 vs AI 分工）
✅ 任务执行机制（任务组织、依赖关系、进度追踪）
✅ 归档机制（Delta Specs 合并、主规范更新、归档组织）

### 下一步建议

1. **实际应用**：在现有项目中初始化 OpenSpec，尝试添加一个小功能
2. **自定义模板**：根据项目需求修改或扩展模板
3. **深入探索**：继续阅读更多源码，理解更多细节

### 重要源码文件清单

| 文件路径 | 作用 |
|---------|------|
| `src/core/schemas/change.schema.ts` | Delta Spec 数据结构定义 |
| `src/core/parsers/change-parser.ts` | Delta Spec 解析器 |
| `src/core/validation/validator.ts` | Delta Spec 验证器 |
| `src/core/specs-apply.ts` | Delta Specs 合并逻辑 |
| `schemas/spec-driven/templates/` | 工件模板目录 |
| `src/commands/workflow/instructions.ts` | AI 指令生成 |
| `src/utils/task-progress.ts` | 任务进度追踪 |
| `src/core/archive.ts` | 归档命令实现 |

### 学习总结

完成了 OpenSpec 1 周快速学习！现在能够：
- ✅ 理解核心概念和哲学（Spec-Driven Development, Artifact-Driven Workflow, Delta Spec, Source of Truth）
- ✅ 熟悉目录结构（specs, changes, archive, 四个 artifacts）
- ✅ 掌握工作流（/opsx:new → /opsx:ff → /opsx:apply → /opsx:archive）
- ✅ 理解核心原理（Delta Spec 解析和合并、工件生成机制、任务执行和依赖、归档和版本管理）
