  }
} catch (err: any) {
  console.log(String(err.message || err));
  console.log('Aborted. No files were changed.');
  return; // 中止归档，保持原样
}

// 所有验证通过 → 写入文件
for (const p of prepared) {
  await writeUpdatedSpec(p.update, p.rebuilt, p.counts);
}
```

**准确性保证机制**：

### 1. 重复检查
- 章节内：ADDED/MODIFIED/REMOVED/RENAMED 中不能有重复
- 跨章节：同一需求不能出现在多个章节

### 2. 冲突检查
- MODIFIED vs REMOVED：不能同时存在
- MODIFIED vs ADDED：不能同时存在
- ADDED vs REMOVED：不能同时存在
- RENAMED vs MODIFIED：MODIFIED 必须引用新名称

### 3. 格式要求
- ADDED/MODIFIED：必须有 SHALL/MUST，必须有至少一个场景
- REMOVED：只需要名称
- RENAMED：必须有 FROM 和 TO 配对

### 4. 新规范的验证
- 重建后的规范必须通过完整的 Schema 验证
- 如果验证失败，阻止归档，保留原样

**总结**：
归档后的主规范通过以下方式保持一致性和准确性：
1. ✅ 应用前验证 Delta Specs
2. ✅ 应用后验证重建的规范
3. ✅ 正确的合并顺序（RENAMED → REMOVED → MODIFIED → ADDED）
4. ✅ 保留原有格式和顺序
5. ✅ 跨平台兼容性（Windows 使用 copy + remove）
6. ✅ 错误处理和回滚（准备失败不写入）
7. ✅ 重复和冲突检查
8. ✅ 格式要求验证

如果出现合并错误或验证失败，系统会阻止归档，保持原样，确保主规范不会被破坏。

---

## 学习总结

### 已掌握的核心概念

✅ **Delta Spec 机制**
- 格式定义（ADDED/MODIFIED/REMOVED/RENAMED）
- 解析逻辑（识别章节、提取需求、解析场景）
- 验证规则（重复检查、冲突检查、格式要求）
- 合并顺序（RENAMED → REMOVED → MODIFIED → ADDED）

✅ **工件生成机制**
- 模板系统（四个工件模板）
- AI 指令生成（context、rules、template）
- 模板 vs AI 的分工（结构 vs 内容）
- 生成流程（加载模板 → 生成指令 → AI 填充 → 写入文件）

✅ **任务执行机制**
- 任务组织（按章节：Infrastructure → Components → Features → Testing）
- 依赖关系（基础先完成，后续依赖前面）
- 进度追踪（解析复选框、计算进度）
- 执行顺序（推荐顺序 + 并行任务）

✅ **归档机制**
- Delta Specs 合并（查找 → 准备 → 验证 → 写入）
- 主规范更新（重建文件、保持格式）
- 归档组织（带日期的归档目录）
- 一致性保证（多层次验证、错误处理）

### 能够解释的问题

1. ✅ Delta Spec 中的 MODIFIED 和 REMOVED 冲突如何处理？
   - 验证阶段会检测冲突，阻止归档
   - 用户必须手动修正

2. ✅ 工件生成是模板化还是 AI 生成？
   - 模板化 + AI 填充的混合模式
   - 模板定义结构，AI 填充内容

3. ✅ 归档后的主规范如何保持一致性？
   - 多层次验证（应用前、重建后）
   - 正确的合并顺序
   - 错误处理和回滚
   - 重复和冲突检查

### 深入理解的关键

1. **数据流**：从 Delta Spec → 验证 → 合并 → 重建 → 验证 → 写入
2. **顺序很重要**：RENAMED → REMOVED → MODIFIED → ADDED
3. **验证是关键**：应用前验证、重建后验证、双重保障
4. **模板 vs AI**：各司其职，模板定义结构，AI 填充内容
5. **错误处理**：准备失败不写入，保持原样
